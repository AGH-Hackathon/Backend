import os
from typing import List, Dict
import string
import random

# import openai

import torch
from min_dalle import MinDalle

from fastapi import FastAPI


# openai.api_key = "secret"
app = FastAPI()


def generate_image_name(size=30, chars=string.ascii_uppercase + string.digits):
    return "".join(random.choice(chars) for _ in range(size))


def generate_and_parse_labels(num_of_labels: int) -> List[str]:
    # TODO: uncomment to use Chat-GPT
    # completion = openai.ChatCompletion.create(
    #     model="gpt-3.5-turbo",
    #     messages=[
    #         {
    #             "role": "user",
    #             "content": f"Generate {num_of_labels} weird descriptions for images that will be generated by an "
    #                        f"AI model and list every description in a new line without enumeration and return only it "
    #                        f"for easy parsing."
    #         }
    #     ]
    # )
    # return completion.choices[0].message.content.split("\n\n")
    return [
        "A giant octopus playing a ukulele and singing a happy tune while floating on a bed of clouds.",
        "A giant friendly worm with a big smile, wearing a bowler hat and carrying a briefcase, walking on its hind legs through a busy city street."
    ]


def generate_images(labels: List[str]) -> List[Dict[str, str]]:
    model = MinDalle(
        models_root="./pretrained",
        dtype=torch.float16,
        device="cuda",
        is_mega=False,
        is_reusable=True
    )

    image_data: List[Dict[str, str]] = []
    for idx, label in enumerate(labels):
        image = model.generate_image(
            text=label,
            seed=-1,
            grid_size=1,
            is_seamless=False,
            temperature=1,
            top_k=256,
            supercondition_factor=16,
            is_verbose=False
        )

        path: str = "./images"
        image_name: str = generate_image_name()
        if not os.path.exists(path):
            os.makedirs(path)
        path = os.path.join(path, f"{image_name}.png")
        print("saving image to", path)
        image.save(path)

        image_data.append({
            "label": label,
            "filename": image_name
        })

    return image_data


@app.get("/generate/{num_of_images_and_labels}")
async def get_image(num_of_images_and_labels: int):
    if not torch.cuda.is_available():
        raise Exception("CUDA not available. Generating images would take eternity :(")

    labels: List[str] = generate_and_parse_labels(num_of_images_and_labels)
    image_data: List[Dict[str, str]] = generate_images(labels)
    return image_data
